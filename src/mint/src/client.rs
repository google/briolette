// Copyright 2023 The Briolette Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use briolette_proto::briolette::mint::mint_client::MintClient;
use chrono::Utc;

use briolette_proto::briolette::mint::GetTokensRequest;
use briolette_proto::briolette::token::{tag, Amount, AmountType, SignedTicket, Tag};
use briolette_proto::briolette::Version;
use briolette_proto::BrioletteClientHelper;

use prost::Message;
use std::path::{Path, PathBuf};
use tokio;
use tonic::transport::Uri;

use clap::Parser as ClapParser;
#[derive(ClapParser, Debug)]
#[command(author, version)]
#[command(about = "basic integration test client for mint")]
struct Args {
    // Path to a ticket to issue to
    #[arg(
        short = 't',
        long,
        value_name = "FILE",
        default_value = "data/wallet/ticket.0.pb"
    )]
    ticket: PathBuf,
    // Prefix to write tokens to
    #[arg(short = 'o', long, value_name = "STRING", default_value = "data/mint/")]
    output_prefix: String,

    // Validate server URI
    #[arg(
        short = 'c',
        long,
        value_name = "URI",
        default_value = "http://[::1]:50053"
    )]
    mint_uri: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    let mut client = MintClient::multiconnect(&Uri::try_from(&args.mint_uri)?).await?;

    // Now load a TTC sk we can sign our ticket request with.
    // This data is generated by ../wallet but we don't want a dependency here.
    let ticket_0 = std::fs::read(&args.ticket).expect("clerk client generated ticket is missing");
    let signed_ticket = SignedTicket::decode(ticket_0.as_slice()).unwrap();

    let request = GetTokensRequest {
        version: Version::Current.into(),
        amount: Some(Amount {
            whole: 1,
            fractional: 0.0,
            code: AmountType::TestToken.into(),
        }),
        tags: vec![Tag {
            value: Some(tag::Value::ValidUntil(Utc::now().timestamp() as u64)),
        }],
        count: 10,
        ticket: Some(signed_ticket),
    };
    println!("Calling mint: {:?}", request);
    let response = client.get_tokens(request).await?;
    for (index, token) in response.into_inner().tokens.iter().enumerate() {
        // TODO: Verify token provenance
        let mut disk_token = token.clone();
        disk_token
            .base
            .as_mut()
            .unwrap()
            .transfer
            .as_mut()
            .unwrap()
            .previous_signature
            .clear();
        println!("DISK_TOKEN={:?}", disk_token);
        std::fs::write(
            Path::new(&format!("{}token.{}.pb", &args.output_prefix, index)),
            disk_token.encode_to_vec(),
        )
        .unwrap();
    }

    Ok(())
}
