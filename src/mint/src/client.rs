// Copyright 2023 The Briolette Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use briolette_proto::briolette::mint::mint_client::MintClient;
use chrono::Utc;

use briolette_proto::briolette::mint::GetTokensRequest;
use briolette_proto::briolette::token::{tag, Amount, AmountType, SignedTicket, Tag};
use briolette_proto::briolette::Version;
use briolette_proto::BrioletteClientHelper;

use prost::Message;
use std::path::Path;
use tokio;
use tonic::transport::Uri;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = MintClient::multiconnect(&Uri::try_from("http://[::1]:50053")?).await?;

    // Now load a TTC sk we can sign our ticket request with.
    // This data is generated by ../wallet but we don't want a dependency here.
    let ticket_0 = std::fs::read(&Path::new("data/wallet/ticket.0.pb"))
        .expect("clerk client generated ticket is missing");
    let signed_ticket = SignedTicket::decode(ticket_0.as_slice()).unwrap();

    let request = GetTokensRequest {
        version: Version::Current.into(),
        amount: Some(Amount {
            whole: 1,
            fractional: 0.0,
            code: AmountType::TestToken.into(),
        }),
        tags: vec![Tag {
            value: Some(tag::Value::ValidUntil(Utc::now().timestamp() as u64)),
        }],
        count: 10,
        ticket: Some(signed_ticket),
    };
    println!("Calling mint: {:?}", request);
    let response = client.get_tokens(request).await?;
    for (index, token) in response.into_inner().tokens.iter().enumerate() {
        // TODO: Verify token provenance
        let mut disk_token = token.clone();
        disk_token
            .base
            .as_mut()
            .unwrap()
            .transfer
            .as_mut()
            .unwrap()
            .previous_signature
            .clear();
        println!("DISK_TOKEN={:?}", disk_token);
        std::fs::write(
            Path::new(&format!("data/mint/token.{}.pb", index)),
            disk_token.encode_to_vec(),
        )
        .unwrap();
    }

    Ok(())
}
