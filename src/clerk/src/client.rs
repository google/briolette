// Copyright 2023 The Briolette Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use briolette_crypto::v0;
use briolette_proto::briolette::clerk::clerk_client::ClerkClient;
use briolette_proto::briolette::clerk::{
    EpochRequest, GetTicketsRequest, TicketRequest, TicketRequests,
};
use briolette_proto::briolette::Version;
use briolette_proto::briolette::{Error as BrioletteError, ErrorCode as BrioletteErrorCode};
use briolette_proto::BrioletteClientHelper;
use rand::Rng;

use prost::Message;
use std::path::{Path, PathBuf};
use tokio;
use tonic::transport::Uri;

use clap::Parser as ClapParser;

#[derive(ClapParser, Debug)]
#[command(author, version)]
#[command(about = "basic integration test client for Clerk")]
struct Args {
    // Path to NAC issuer group public key
    #[arg(
        short = 'n',
        long,
        value_name = "FILE",
        default_value = "data/wallet/nac.gpk"
    )]
    nac_group_public_key: PathBuf,
    // Path to NAC secret key
    #[arg(
        short = 'N',
        long,
        value_name = "FILE",
        default_value = "data/wallet/nac.sk"
    )]
    nac_secret_key: PathBuf,
    // Path to NAC credential
    #[arg(
        short = 'c',
        long,
        value_name = "FILE",
        default_value = "data/wallet/nac.cred"
    )]
    nac_credential: PathBuf,
    // Path to public Ticket Signing Key
    #[arg(
        short = 'T',
        long,
        value_name = "FILE",
        default_value = "data/clerk/ticket.pk"
    )]
    ticket_signing_public_key: PathBuf,
    // Path to wallet token transfer ticket credential group public key (TTC-GPK)
    // TODO(redpig) add list support
    // TODO(redpig) cross-check ttc_issuer.gpk matches wallet fetched gpk
    #[arg(
        short = 'W',
        long,
        value_name = "FILE",
        default_value = "data/registrar/ttc_issuer.gpk"
    )]
    ttc_group_public_key: PathBuf,
    #[arg(
        short = 'w',
        long,
        value_name = "FILE",
        default_value = "data/wallet/ttc.cred"
    )]
    ttc_credential: PathBuf,
    // Clerk server URI
    #[arg(
        short = 'c',
        long,
        value_name = "URI",
        default_value = "http://[::1]:50052"
    )]
    clerk_uri: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();
    let mut client = ClerkClient::multiconnect(&Uri::try_from(args.clerk_uri.clone())?).await?;
    let mut rng = rand::thread_rng();

    let eu;
    // 1. Fetch EpochUpdate
    let epoch_request = tonic::Request::new(EpochRequest::default());
    let epoch_response = client.get_epoch(epoch_request).await;
    match epoch_response {
        Ok(response) => {
            eu = response.into_inner().update.unwrap();
            println!("Fetched EpochUpdate: {:?}", eu);
        }
        Err(status) => {
            let ce: BrioletteError = BrioletteError::decode(status.details()).unwrap();
            if ce.code == BrioletteErrorCode::InvalidServerState as i32 {
                eprintln!("Run epoch-generate!");
                return Err(status.into());
            } else {
                return Err(status.into());
            }
        }
    };

    // 2. Create new GetTicketsRequest
    // 2a. Load wallet credentials (NAC, TTC)
    // 2b. Generate TicketRequests
    // 2b.1. Randomize TTC credentials x8
    // 2b.2. Pick 8 random numbers in the EpochUpdate.group_bitfield size.
    // 2c. Create GetTicketsRequest
    // 2d. On success, receive tickets and output to disk

    // Now load a NAC sk we can sign our ticket request with.
    // This data is generated by ../wallet but we don't want a dependency here.
    let nac_sk = std::fs::read(&args.nac_secret_key).unwrap();
    let nac_cred = std::fs::read(&args.nac_credential).unwrap();
    let nac_gpk = std::fs::read(&args.nac_group_public_key).unwrap();

    // Load in the TTC credential so we can create randomized credentials.
    let ttc_gpk = std::fs::read(&args.ttc_group_public_key).unwrap();
    let ttc_cred = std::fs::read(&args.ttc_credential).unwrap();
    // Create 10 randomized credentials.
    let mut requests = TicketRequests::default();
    for _i in 0..9 {
        let mut credential = vec![];
        assert!(
            v0::randomize_credential(&ttc_cred, &mut credential),
            "failed to randomize the wallet ttc credential!"
        );
        // Group count
        let max_groups = eu.data.clone().unwrap().group_bitfield.len() * 8;
        let group_number: u32 = rng.gen_range(0..max_groups) as u32;
        let tr = TicketRequest {
            credential,
            group_number,
        };
        requests.request.push(tr);
    }
    // Serialize the request list and sign with the NAC, using the current epoch as the basename.
    let requests_serialized = requests.encode_to_vec();
    let basename = Some(eu.data.clone().unwrap().epoch.to_le_bytes().to_vec());
    let mut signature = vec![];
    assert!(v0::sign(
        &requests_serialized,
        &nac_cred,
        &nac_sk,
        &basename,
        true,
        &mut signature
    ));

    let request = GetTicketsRequest {
        version: Version::Current.into(),
        known_epoch: eu.data.clone().unwrap().epoch,
        nac_public_key: nac_gpk,
        ttc_public_key: ttc_gpk,
        requests: Some(requests),
        nac_signature: signature,
    };
    let response = client.get_tickets(request).await?;
    println!("RESPONSE={:?}", response);
    // Let's save the tickets to enable easy use in other demo service clients.
    let msg = response.into_inner();
    for (index, signed_ticket) in msg.tickets.iter().enumerate() {
        std::fs::write(
            Path::new(&format!("data/wallet/ticket.{}.pb", index)),
            signed_ticket.encode_to_vec(),
        )
        .unwrap();
    }

    Ok(())
}
