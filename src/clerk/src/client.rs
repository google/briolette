// Copyright 2023 The Briolette Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use briolette_crypto::v0;
use briolette_proto::briolette::clerk::clerk_client::ClerkClient;
use briolette_proto::briolette::clerk::{
    EpochRequest, GetTicketsRequest, TicketRequest, TicketRequests,
};
use briolette_proto::briolette::Version;
use briolette_proto::briolette::{Error as BrioletteError, ErrorCode as BrioletteErrorCode};
use briolette_proto::BrioletteClientHelper;
use rand::Rng;

use prost::Message;
use std::path::Path;
use tokio;
use tonic::transport::Uri;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut client = ClerkClient::multiconnect(&Uri::try_from("http://[::1]:50052")?).await?;
    let mut rng = rand::thread_rng();

    let eu;
    // 1. Fetch EpochUpdate
    let epoch_request = tonic::Request::new(EpochRequest::default());
    let epoch_response = client.get_epoch(epoch_request).await;
    match epoch_response {
        Ok(response) => {
            eu = response.into_inner().update.unwrap();
            println!("Fetched EpochUpdate: {:?}", eu);
        }
        Err(status) => {
            let ce: BrioletteError = BrioletteError::decode(status.details()).unwrap();
            if ce.code == BrioletteErrorCode::InvalidServerState as i32 {
                eprintln!("Run epoch-generate!");
                return Err(status.into());
            } else {
                return Err(status.into());
            }
        }
    };

    // 2. Create new GetTicketsRequest
    // 2a. Load wallet credentials (NAC, TTC)
    // 2b. Generate TicketRequests
    // 2b.1. Randomize TTC credentials x8
    // 2b.2. Pick 8 random numbers in the EpochUpdate.group_bitfield size.
    // 2c. Create GetTicketsRequest
    // 2d. On success, receive tickets and output to disk

    // Now load a NAC sk we can sign our ticket request with.
    // This data is generated by ../wallet but we don't want a dependency here.
    let nac_sk = std::fs::read(&Path::new("data/wallet/nac.sk")).unwrap();
    let nac_cred = std::fs::read(&Path::new("data/wallet/nac.cred")).unwrap();
    let nac_gpk = std::fs::read(&Path::new("data/wallet/nac.gpk")).unwrap();

    // Load in the TTC credential so we can create randomized credentials.
    let ttc_gpk = std::fs::read(&Path::new("data/wallet/ttc.gpk")).unwrap();
    let ttc_cred = std::fs::read(&Path::new("data/wallet/ttc.cred")).unwrap();
    // Create 10 randomized credentials.
    let mut requests = TicketRequests::default();
    for _i in 0..9 {
        let mut credential = vec![];
        assert!(
            v0::randomize_credential(&ttc_cred, &mut credential),
            "failed to randomize the wallet ttc credential!"
        );
        // Group count
        let max_groups = eu.data.clone().unwrap().group_bitfield.len() * 8;
        let group_number: u32 = rng.gen_range(0..max_groups) as u32;
        let tr = TicketRequest {
            credential,
            group_number,
        };
        requests.request.push(tr);
    }
    // Serialize the request list and sign with the NAC, using the current epoch as the basename.
    let requests_serialized = requests.encode_to_vec();
    let basename = Some(eu.data.clone().unwrap().epoch.to_le_bytes().to_vec());
    let mut signature = vec![];
    assert!(v0::sign(
        &requests_serialized,
        &nac_cred,
        &nac_sk,
        &basename,
        true,
        &mut signature
    ));

    let request = GetTicketsRequest {
        version: Version::Current.into(),
        known_epoch: eu.data.clone().unwrap().epoch,
        nac_public_key: nac_gpk,
        ttc_public_key: ttc_gpk,
        requests: Some(requests),
        nac_signature: signature,
    };
    let response = client.get_tickets(request).await?;
    println!("RESPONSE={:?}", response);
    // Let's save the tickets to enable easy use in other demo service clients.
    let msg = response.into_inner();
    for (index, signed_ticket) in msg.tickets.iter().enumerate() {
        std::fs::write(
            Path::new(&format!("data/wallet/ticket.{}.pb", index)),
            signed_ticket.encode_to_vec(),
        )
        .unwrap();
    }

    Ok(())
}
