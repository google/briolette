// Copyright 2023 The Briolette Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use briolette_proto::briolette::clerk::clerk_client::ClerkClient;
use briolette_proto::briolette::clerk::{EpochData, EpochRequest, EpochUpdate, ExtendedEpochData};
use briolette_proto::briolette::tokenmap::revocation_data_request::Select;
use briolette_proto::briolette::tokenmap::token_map_client::TokenMapClient;
use briolette_proto::briolette::tokenmap::{RevocationDataRequest, SelectGroup};
use briolette_proto::briolette::{Error as BrioletteError, ErrorCode as BrioletteErrorCode};
use log::*;
use p256::{
    ecdsa::{signature::RandomizedSigner, Signature, SigningKey},
    pkcs8::{DecodePrivateKey, EncodePublicKey},
    SecretKey,
};
use rand_core::OsRng;
use sha2::{Digest, Sha256};

use prost::Message;
use std::path::Path;
use tokio;

// TODO: Parameterize
const EPOCH_SECONDS: u64 = 86400;
const GROUP_MAX: u32 = 64;

async fn get_revoked_groups(
    group_max: u32,
    now: u64,
    uri: &String,
) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    // TODO: Parameterize
    if let Ok(mut client) = TokenMapClient::connect(uri.clone()).await {
        trace!("Connected to tokenmap!");
        let request = RevocationDataRequest {
            select: Some(Select::Group(SelectGroup::All.into())),
        };
        trace!("Calling tokenmap: {:?}", request);
        let response = client.revocation_data(request).await?;
        debug!("Response: {:?}", response);
        let mut groups: Vec<u8> = vec![];
        groups.resize(group_max as usize, 0);
        let msg = response.into_inner();
        for entry in msg.entries.iter() {
            if let Some(data) = entry.data.as_ref() {
                for group in data.groups.iter() {
                    if group.expiration > now {
                        let byte: usize = (group.number % 8) as usize;
                        let bit = group.number / 8;
                        let mut val: u8 = groups[byte];
                        val |= 1 << bit;
                        groups[byte] = val;
                    }
                }
            }
        }
        return Ok(groups);
    }
    return Err(Box::new(tonic::Status::failed_precondition(
        "failed to connect",
    )));
}

pub async fn make_epoch_update() -> EpochUpdate {
    let mut epoch_update = EpochUpdate::default();
    let now = chrono::offset::Utc::now().timestamp() as u64;
    let mut eed = ExtendedEpochData::default();
    eed.epoch_seconds = EPOCH_SECONDS;

    // Load the epoch keys generated by the server.
    let epoch_sk = std::fs::read(Path::new("data/clerk/epoch.sk"))
        .expect("Please generate Epoch keys before running!");
    let sk = SecretKey::from_pkcs8_der(epoch_sk.as_slice()).unwrap();
    let pk_der = sk.public_key().to_public_key_der().unwrap().into_vec();
    let epoch_signer: SigningKey = sk.into();
    eed.epoch_signing_keys.push(pk_der.clone());
    epoch_update.signing_key = pk_der;

    // Read ticket server public key
    let ticket_pk_in = std::fs::read(&Path::new("data/clerk/ticket.pk"))
        .expect("Please generate Clerk keys before running!");
    // We'll need this to verify the response.
    eed.ticket_signing_keys.push(ticket_pk_in);
    // We need to establish trust
    let mint_pk_in = std::fs::read(&Path::new("data/mint/mint.pk"))
        .expect("Please generate Mint keys before running!");
    eed.mint_signing_keys.push(mint_pk_in);

    // Now load in a TTC gpk
    let ttc_gpk = std::fs::read(&Path::new("data/registrar/ttc_issuer.gpk"))
        .expect("Please generate wallet group keys before running!");
    eed.ttc_group_public_keys.push(ttc_gpk);
    // TODO: Provide an out of bands mean for the servers to track acceptable NAC GPKs
    // let nac_gpk = std::fs::read(&Path::new("../registar/data/wallet.nac.gpk")).unwrap();

    let group_bytes: usize = (GROUP_MAX / 8) as usize;
    let group_bitfield: Vec<u8>;
    let tokenmap_addr = "http://[::1]:50054".to_string();
    let window = now - (now % eed.epoch_seconds);
    if let Ok(groups) = get_revoked_groups(GROUP_MAX, window, &tokenmap_addr).await {
        group_bitfield = groups;
    } else {
        group_bitfield = vec![0; group_bytes];
    }

    epoch_update.data = Some(EpochData {
        epoch: window,
        group_bitfield: group_bitfield,
        extended_epoch_data_hash: Sha256::digest(eed.encode_to_vec()).to_vec(),
    });
    epoch_update.extended_data = Some(eed);

    // Compute signature over data
    let encoded_ed = epoch_update.data.clone().unwrap().encode_to_vec();
    let sig: Signature = epoch_signer.sign_with_rng(&mut OsRng, encoded_ed.as_slice());
    epoch_update.epoch_signature = sig.to_vec();
    return epoch_update;
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    stderrlog::new()
        .quiet(false)
        .verbosity(2)
        .timestamp(stderrlog::Timestamp::Millisecond)
        .init()
        .unwrap();
    let mut client = ClerkClient::connect("http://[::1]:50052").await?;

    // 0. Fetch EpochUpdate
    let mut eu = None;
    let epoch_request = tonic::Request::new(EpochRequest::default());
    let mut do_epoch_update = false;
    let epoch_response = client.get_epoch(epoch_request).await;
    match epoch_response {
        Ok(response) => {
            debug!("RESPONSE={:?}", response);
            eu = Some(response.into_inner().update.unwrap());
        }
        Err(status) => {
            let ce: BrioletteError = BrioletteError::decode(status.details()).unwrap();
            if ce.code == BrioletteErrorCode::InvalidServerState as i32 {
                do_epoch_update = true;
            } else {
                return Err(status.into());
            }
        }
    };
    // Perform an update if we're in the next window or the current update is weird.
    let now = chrono::offset::Utc::now().timestamp() as u64;
    if let Some(prev_epoch) = eu.as_ref() {
        if let Some(extended_data) = prev_epoch.extended_data.as_ref() {
            let mut seconds = EPOCH_SECONDS;
            if extended_data.epoch_seconds > 0 {
                seconds = extended_data.epoch_seconds;
            }
            let window = now - (now % seconds);
            if let Some(data) = prev_epoch.data.as_ref() {
                do_epoch_update = data.epoch < window;
            } else {
                do_epoch_update = true;
            }
        }
    }

    if eu.is_none() || do_epoch_update {
        // 1. On error, if InvalidServerState, create new EpochUpdate.
        // -. Load the epoch signing key from data/
        // -. Load the NAC and TTC group public keys from ../registrar
        // -. Load the Clerk and Mint public key from data
        // -. Collect revocation data from tokenmap
        // -. Build an ExtendedEpochData
        // -. Build an EpochData
        // -. Sign the EpochData
        // -. Build an EpochUpdate
        // -. Submit the update

        info!("Doing an epoch update for the clerk server...");

        // TODO: Use prior EU as a base!
        let epoch_update = make_epoch_update().await;
        let request = tonic::Request::new(epoch_update);
        info!("Sending the update...");
        let response = client.add_epoch(request).await?;
        debug!("RESPONSE={:?}", response);
    } else {
        info!("No epoch update required.");
    }

    Ok(())
}
