// Copyright 2023 The Briolette Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use briolette_proto::briolette::clerk::clerk_client::ClerkClient;
use briolette_proto::briolette::clerk::{EpochData, EpochRequest, EpochUpdate, ExtendedEpochData};
use briolette_proto::briolette::tokenmap::revocation_data_request::Select;
use briolette_proto::briolette::tokenmap::token_map_client::TokenMapClient;
use briolette_proto::briolette::tokenmap::{RevocationDataRequest, SelectGroup};
use briolette_proto::briolette::{Error as BrioletteError, ErrorCode as BrioletteErrorCode};
use briolette_proto::briolette::{ServiceMapInterface, ServiceName};
use briolette_proto::BrioletteClientHelper;
use clap::Parser as ClapParser;
use log::*;
use p256::{
    ecdsa::{signature::RandomizedSigner, Signature, SigningKey},
    pkcs8::{DecodePrivateKey, EncodePublicKey},
    SecretKey,
};
use rand_core::OsRng;
use sha2::{Digest, Sha256};

use prost::Message;
use std::path::PathBuf;
use tokio;
use tonic::transport::Uri;

async fn get_revoked_groups(
    group_max: u32,
    now: u64,
    uri: &String,
) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    // TODO: Parameterize
    if let Ok(mut client) = TokenMapClient::multiconnect(&Uri::try_from(uri.clone())?).await {
        trace!("Connected to tokenmap!");
        let request = RevocationDataRequest {
            select: Some(Select::Group(SelectGroup::All.into())),
        };
        trace!("Calling tokenmap: {:?}", request);
        let response = client.revocation_data(request).await?;
        debug!("Response: {:?}", response);
        let mut groups: Vec<u8> = vec![];
        groups.resize(group_max as usize, 0);
        let msg = response.into_inner();
        for entry in msg.entries.iter() {
            if let Some(data) = entry.data.as_ref() {
                for group in data.groups.iter() {
                    if group.expiration > now {
                        let byte: usize = (group.number % 8) as usize;
                        let bit = group.number / 8;
                        let mut val: u8 = groups[byte];
                        val |= 1 << bit;
                        groups[byte] = val;
                    }
                }
            }
        }
        return Ok(groups);
    }
    return Err(Box::new(tonic::Status::failed_precondition(
        "failed to connect",
    )));
}

// TODO(redpig): Move this into a helper to make it easier for testing to use.
async fn make_epoch_update(args: &Args) -> EpochUpdate {
    let mut epoch_update = EpochUpdate::default();
    let now = chrono::offset::Utc::now().timestamp() as u64;
    let mut eed = ExtendedEpochData::default();
    eed.epoch_seconds = args.epoch_length;

    // Load the epoch keys generated by the server.
    let epoch_sk = std::fs::read(&args.epoch_signing_secret_key)
        .expect("Please generate Epoch keys before running!");
    let sk = SecretKey::from_pkcs8_der(epoch_sk.as_slice()).unwrap();
    let pk_der = sk.public_key().to_public_key_der().unwrap().into_vec();
    let epoch_signer: SigningKey = sk.into();
    eed.epoch_signing_keys.push(pk_der.clone());
    epoch_update.signing_key = pk_der;

    // Read ticket server public key
    let ticket_pk_in = std::fs::read(&args.ticket_signing_public_key)
        .expect("Please generate Clerk keys before running!");
    // We'll need this to verify the response.
    eed.ticket_signing_keys.push(ticket_pk_in);
    // We need to establish trust
    let mint_pk_in =
        std::fs::read(&args.mint_public_key).expect("Please generate Mint keys before running!");
    eed.mint_signing_keys.push(mint_pk_in);

    // Now load in a TTC gpk
    let ttc_gpk = std::fs::read(&args.ttc_group_public_key)
        .expect("Please generate wallet group keys before running!");
    eed.ttc_group_public_keys.push(ttc_gpk);
    // TODO: Provide an out of bands mean for the servers to track acceptable NAC GPKs
    // let nac_gpk = std::fs::read(&Path::new("../registar/data/wallet.nac.gpk")).unwrap();

    // Add the service URIs
    // TODO(redpig): Populate via config server message or commandline args
    eed.service_map
        .add(ServiceName::Registrar, &args.registrar_uri);
    eed.service_map.add(ServiceName::Ticket, &args.clerk_uri);
    eed.service_map.add(ServiceName::Epoch, &args.clerk_uri);
    eed.service_map
        .add(ServiceName::Validate, &args.validate_uri);
    eed.service_map.add(ServiceName::Swap, &args.swap_uri);
    // TODO(redpig) These should only be added if the tokenmap or mint services are used by client devices.
    eed.service_map.add(ServiceName::Mint, &args.mint_uri);
    eed.service_map
        .add(ServiceName::Tokenmap, &args.tokenmap_uri);

    // Compute the ceil of the division.
    let group_bytes: usize = ((args.group_max + u8::BITS - 1) / u8::BITS) as usize;
    let group_bitfield: Vec<u8>;
    let window = now - (now % eed.epoch_seconds);
    if let Ok(groups) = get_revoked_groups(args.group_max, window, &args.tokenmap_uri).await {
        group_bitfield = groups;
    } else {
        group_bitfield = vec![0; group_bytes];
    }

    epoch_update.data = Some(EpochData {
        epoch: window,
        group_bitfield: group_bitfield,
        extended_epoch_data_hash: Sha256::digest(eed.encode_to_vec()).to_vec(),
    });
    epoch_update.extended_data = Some(eed);

    // Compute signature over data
    let encoded_ed = epoch_update.data.clone().unwrap().encode_to_vec();
    let sig: Signature = epoch_signer.sign_with_rng(&mut OsRng, encoded_ed.as_slice());
    epoch_update.epoch_signature = sig.to_vec();
    return epoch_update;
}

#[derive(ClapParser, Debug)]
#[command(author, version)]
#[command(about = "creates and updates Clerk server epoch state")]
#[command(
    long_about = "This tool allows the manual creation of briolette system state\n\n\
   data. Every client and service in the system expect a system state\n\n\
   update to occur at most once every fixed time increment, or epoch.\n\n\
   \n\n\
   When called, this tool will collect revocation data from the tokenmap\n\n\
   service and the last epoch data, if available, and generate a new\n\n\
   dataset. If needed, the new state data will be uploaded to the Clerk\n\n\
   service for all other system participants to collect."
)]
struct Args {
    // Seconds per-epoch
    #[arg(short = 'L', long, value_name = "seconds", default_value = "86400")]
    epoch_length: u64,
    // Number of total groups
    #[arg(short = 'g', long, value_name = "max_groups", default_value = "64")]
    group_max: u32,
    // Path to Epoch public signing key
    #[arg(
        short = 'E',
        long,
        value_name = "FILE",
        default_value = "data/clerk/epoch.pk"
    )]
    epoch_signing_public_key: PathBuf,
    // Path to Epoch secret signing key
    #[arg(
        short = 'e',
        long,
        value_name = "FILE",
        default_value = "data/clerk/epoch.sk"
    )]
    epoch_signing_secret_key: PathBuf,
    // Path to public Ticket Signing Key
    #[arg(
        short = 'T',
        long,
        value_name = "FILE",
        default_value = "data/clerk/ticket.pk"
    )]
    ticket_signing_public_key: PathBuf,
    // Path to public mint key
    // TODO(redpig) add list support
    #[arg(
        long,
        value_name = "FILE",
        default_value = "data/mint/mint.pk"
    )]
    mint_public_key: PathBuf,
    // Path to wallet token transfer ticket credential group public key (TTC-GPK)
    // TODO(redpig) add list support
    // TODO(redpig) cross-check ttc_issuer.gpk matches wallet fetched gpk
    #[arg(
        short = 'W',
        long,
        value_name = "FILE",
        default_value = "data/registrar/ttc_issuer.gpk"
    )]
    ttc_group_public_key: PathBuf,
    // TokenMap server URI
    #[arg(
        long,
        value_name = "URI",
        default_value = "http://[::1]:50054"
    )]
    tokenmap_uri: String,
    // Swap server URI
    #[arg(
        long,
        value_name = "URI",
        default_value = "http://[::1]:50055"
    )]
    validate_uri: String,
    // Swap server URI
    #[arg(
        long,
        value_name = "URI",
        default_value = "http://[::1]:50057"
    )]
    swap_uri: String,
    // Mint server URI
    #[arg(
        long,
        value_name = "URI",
        default_value = "http://[::1]:50053"
    )]
    mint_uri: String,
    // Registrar server URI
    #[arg(
        long,
        value_name = "URI",
        default_value = "http://[::1]:50051"
    )]
    registrar_uri: String,
    // Clerk server URI
    #[arg(
        long,
        value_name = "URI",
        default_value = "http://[::1]:50052"
    )]
    clerk_uri: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    stderrlog::new()
        .quiet(false)
        .verbosity(2)
        .timestamp(stderrlog::Timestamp::Millisecond)
        .init()
        .unwrap();
    let args = Args::parse();
    let mut client = ClerkClient::multiconnect(&Uri::try_from(args.clerk_uri.clone())?).await?;

    // 0. Fetch EpochUpdate
    let mut eu = None;
    let epoch_request = tonic::Request::new(EpochRequest::default());
    let mut do_epoch_update = false;
    let epoch_response = client.get_epoch(epoch_request).await;
    match epoch_response {
        Ok(response) => {
            debug!("RESPONSE={:?}", response);
            eu = Some(response.into_inner().update.unwrap());
        }
        Err(status) => {
            let ce: BrioletteError = BrioletteError::decode(status.details()).unwrap();
            if ce.code == BrioletteErrorCode::InvalidServerState as i32 {
                do_epoch_update = true;
            } else {
                return Err(status.into());
            }
        }
    };
    // Perform an update if we're in the next window or the current update is weird.
    let now = chrono::offset::Utc::now().timestamp() as u64;
    if let Some(prev_epoch) = eu.as_ref() {
        if let Some(extended_data) = prev_epoch.extended_data.as_ref() {
            let mut seconds = args.epoch_length;
            if extended_data.epoch_seconds > 0 {
                seconds = extended_data.epoch_seconds;
            }
            let window = now - (now % seconds);
            if let Some(data) = prev_epoch.data.as_ref() {
                do_epoch_update = data.epoch < window;
            } else {
                do_epoch_update = true;
            }
        }
    }

    if eu.is_none() || do_epoch_update {
        // 1. On error, if InvalidServerState, create new EpochUpdate.
        // -. Load the epoch signing key from data/
        // -. Load the NAC and TTC group public keys from ../registrar
        // -. Load the Clerk and Mint public key from data
        // -. Collect revocation data from tokenmap
        // -. Build an ExtendedEpochData
        // -. Build an EpochData
        // -. Sign the EpochData
        // -. Build an EpochUpdate
        // -. Submit the update

        info!("Doing an epoch update for the clerk server...");

        // TODO: Use prior EU as a base!
        let epoch_update = make_epoch_update(&args).await;
        let request = tonic::Request::new(epoch_update);
        info!("Sending the update...");
        let response = client.add_epoch(request).await?;
        debug!("RESPONSE={:?}", response);
    } else {
        info!("No epoch update required.");
    }

    Ok(())
}
